\section{Conclusion and Future Work}

In this paper, we focus on efficiency of composition of BX programs.
To achieve fast evaluation, we introduce two different methods using memoization.
From the experimental results of left associative BX composition programs, we know that $put_m$ is fastest method if input size is not very big and $xpg$ is fastest for other left associative programs.
This shows that if programmer choose one method based on the their BX programs and inputs, they can use efficient evaluation. 

%there is no best approach for all BX programs. However, if programmer can choose one method based on the BX programs and inputs, we can use better evaluation methods.

We will continue our work on the following three points.
First is overcomming our limitation in $xpg$. In $xpg$, there are two limitations: only for very-well-behaved programs, restriction for $\pginline{Case}$ (shown in Section 4.1). To be a practical evlauation method, extention of the target language is needed. After extention of the language, we can evaluate more various programs for experimental results.

Second is introducing analysis about BX programs and inputs to choose the best evaluation method automatically.
Currently, programmers have to choose the evaluation method by themselves based on their BX programs and inputs. If automatic choice is possible, we can reduce programmer's burden.

Third is introducing type systems to datatype of sources and view. If we introduce this, we can avoid runtime errors like statically-typed functional languages. We need to investigate more about $construct\_dummy$, because current definition that is used in Section 6 will cause type errors. 

%\begin{itemize}
%\item $construct\_dummy$??
%\end{itemize}

%First is extention of our language. Currently, because $pg$ requires very-well-behaved property



%\begin{itemize}
%\item overcome our limitations
%  \begin{itemize}
%  \item very-well-behaved $\to$ only xpg?
%  \item In case expressions, path's problem $\to$ only xpg?
%  \item How to obtain $\to$ only xpg?
%  \end{itemize}
%  \item tests for big BX programs
%  \item Type system \& Typing -- for safety
%  \item analysis about programs/inputs to choose the best method automatically
%\end{itemize}



%The essential finding comes from the idea of tupling: in very-well behaved BX programs we can use $put$ as a compliment function for $get$, and vice versa.
%Based on the idea, we introduced $pg$, and improved it by several optimization techniques. From experimental results, our fastest approach $xpg$ is faster than other approaches for non purely right associative compositions. For right associative compositions, the original approach (miniBiGUL) is faster than $xpg$ because $xpg$ has some overhead cost. However this is not a problem, because usually programs are mix of left and right associative. If programmers know that their programs are purely right associative, they can choose miniBiGUL.

%We will continue our work on the following points. First, our target language is limited to very-well behaved, because our main idea requires the put-put property. However, for practical programs, we need to extend our work to overcome the current limitations.

%\begin{itemize}
%\item Extend our approach -- overcome our limitations
%  \begin{itemize}
%  \item treat well-behaved programs -- How to treat adaptive cases
%  \item In case expressions, the programs that use the different paths (put and get)
%  \end{itemize}
%\item How to obtain dummy?
%\item Type system \& Typing -- for safety
%\end{itemize}
