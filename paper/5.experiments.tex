\section{Experiments}

We have implemented all methods described above in the same environment as follows: macOS 10.14.6, processor Intel Core i7 (2.6 GHz), RAM 16 GB 2400 MHz DDR4, OCaml 4.07.1. The OCaml runtime system options and garbage collection parameters are set as default. There is no type system in our implementation\footnote{\url{https://mega.nz/\#!yUsgyCxA!yrJfINiwtCwhmd4McYMz2xsFa-ljkgGKmMi839ut5gA}}, so instead of constructing some dummies which are necessary for $pg$, $cpg$, $kpg$ and $xpg$, we replace them by the updated view that helps a program in the $put$ direction valid.

\subsection{Test cases}

We have conducted 7 test cases shown in Table \ref{tab:test-cases}. Although the number of programs is not so much, they are not trivial and can be completely used in practice. In $s_r$ and $v_r$ are respectively updated source and view which are produced by applying $put$ and $get$ on original source $s_0$ and view $v_0$. This means: $s_r = \putbx{bx}{s_0}{v_0}$ and $v_r = \getbx{bx}{s_0}$, where $bx$ is present in the table. These $bx$ are left associative composition since we we are only interested in this kind of program in the paper. Please note that the results $s_r$ and $v_r$ do not depend on the associative style of the composition.

\begin{table}[hbt!]
    \centering
    \caption{Test cases}
    \label{tab:test-cases}
    \begin{tabular*}{\textwidth}{|l @{\extracolsep{\fill}}|l|l|c|c|c|c|}
        \hline
        \multirow{2}{*}{No} & \multicolumn{1}{c|}{\multirow{2}{*}{Name}} & \multicolumn{1}{c|}{\multirow{2}{*}{Type}} & \multicolumn{2}{c|}{Input} & \multicolumn{2}{c|}{Output} \\ \cline{4-7} 
        & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{$s_0$} & \multicolumn{1}{c|}{$v_0$} & \multicolumn{1}{c|}{$s_r$} & \multicolumn{1}{c|}{$v_r$} \\ \hline
        1 & lcomp-phead-ldata & straight line & $\underbrace{[[\ldots[1]\ldots]]}_{\text{n+1 times}}$ & 100 & $\underbrace{[[\ldots[100]\ldots]]}_{\text{n+1 times}}$ & 1 \\ \hline
        2 & lcomp-ptail & straight line & [1,$\ldots$,n+1] & [1,$\ldots$,10] & $s_0 \ @ \ v_0$ & [\ ] \\ \hline
        3 & lcomp-ptail-ldata & straight line & $\underbrace{[L,\ldots,L]}_{\text{n+1 times}}$ & $\underbrace{[L,\ldots,L]}_{\text{10 times}}$ & $\underbrace{[L,\ldots,L]}_{\text{n+11 times}}$ & [\ ] \\ \hline
        4 & lcomp-bsnoc & straight line & [1,$\ldots$,n-1] & [1,$\ldots$,n-1] & [1,$\ldots$,n-1] & [1,$\ldots$,n-1] \\ \hline
        5 & lcomp-bsnoc-ldata & straight line & $\underbrace{[L,\ldots,L]}_{\text{n-1 times}}$ & $\underbrace{[L,\ldots,L]}_{\text{n-1 times}}$ & $\underbrace{[L,\ldots,L]}_{\text{n-1 times}}$ & $\underbrace{[L,\ldots,L]]}_{\text{n-1 times}}$ \\ \hline
        6 & breverse & recursion & [1,$\ldots$,n] & [1,$\ldots$,n] & [n,$\ldots$,1] & [n,$\ldots$,1] \\ \hline
        7 & breverse-ldata & recursion & $\underbrace{[L,\ldots,L]}_{\text{n times}}$ & $\underbrace{[L,\ldots,L]}_{\text{n times}}$ & $\underbrace{[L,\ldots,L]}_{\text{n times}}$ & $\underbrace{[L,\ldots,L]}_{\text{n times}}$ \\ \hline
    \end{tabular*}
\end{table}

The first 5 cases merely use $n$ $\circ$ operators to make straight-line compositions from $n + 1$ similar \textit{pure} programs. We use the term \textit{pure} here to refer non-recursion compositions. The prefix \textit{lcomp} means that the associate precedence of $\circ$ in a straight-line composition is left. The suffix \textit{ldata} indicates that the input size is large. The symbol $L$ used in \textit{ldata} test cases can be expressed as a complex list as follows: $L = [T,\ldots,T] \ (n \ T\text{s}), \ T = [A,\ldots,A] \ (10 \ A\text{s}), \ A = [1,\ldots,5]$. These structures are only intended to generate data enough large for observing experimental results. 

We introduced the composition $phead \circ phead$ earlier. The compositions of many \textit{phead} do things similarly, the head of a head element inside a super nested list which expresses the source should be changed by the view. Because of the type of the source, this program is seen as a \textit{ldata} case. Next, we briefly explain the behavior of the remaining compositions in table \ref{tab:test-cases}.

$\putbx{ptail}{s}{v}$ accepts a source list $s$ and a view list $v$ to produce a new list by replacing the tail of $s$ with $v$. $\getbx{ptail}{s}$ return the tail of the source list $s$. The compositions of many $ptail$, in the \textit{put} direction, replace a part of the tail of the source list by the view list, in the \textit{get} direction, returns the such tail from the the source.

$\putbx{bsnoc}{s}{v}$ accepts a source $s$ and a view $v$ as two same length lists, to produce a new list by moving the last element of $v$ to its first position. $\getbx{ptail}{s}$ return another list by moving the first element of the list $s$ to its end position. The compositions of many \textit{ptail}, in the \textit{put} direction, create a permutation of the view list if the source list has a same length with the view, in the \textit{get} direction, produce a permutation of the source list.

\textit{breverse} is defined in terms of \textit{bfoldr}, in the \textit{put} direction, produces a reverse of the view list if the source list has a same length with the view, in the \textit{get} direction, produce a reverse of the source list.

\subsection{Results}

\input{result.tex}

Figure \ref{fig:result} illustrates the evaluation times of $put$ in minBiGUL, $put_m$ in minBiGUL$_m$ and $xpg$ for 7 test cases. We simply ignore the experimental results of $pg$, $cpg$ and $kpg$ since they are shown the slowness compared to $xpg$. For left associative compositions, $put$ works poorly because of the number of reevaluated $get$s. The figure shows $put_m$ and $xpg$ are better than $put$ in some cases. The left of figure contains tests using not very big input, and the right includes of the others. We see that $put_m$ is the fastest method if the input size is not too large. However, if the input size is large enough, $put_m$ will be slower quickly due to times for manipulating data in the table. At that time, $xpg$ proved to be the most effective method.
