% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}
%
\usepackage{graphicx}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{subfig}
\usepackage{lmodern}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following line
% to display URLs in blue roman font according to Springer's eBook style:
% \renewcommand\UrlFont{\color{blue}\rmfamily}

\pgfplotsset{compat=1.12}

\setlength{\parindent}{0pt}
\renewcommand{\indent}{\hspace*{0pt}}

\newcommand{\tab}{\hspace*{5mm}}
\newcommand{\qtab}{\hspace*{5mm} \ \quad}

\newcommand{\sif}[3]{\text{if } #1 \text{ then } #2 \text{ else } #3}
\newcommand{\product}[2]{#1 \ prod \ #2}
\newcommand{\tuple}[2]{(#1 :: #2)}
\newcommand{\rearrS}[2]{rearrS \ #1 \ #2}
\newcommand{\rearrV}[2]{rearrV \ #1 \ #2}
\newcommand{\casebx}[6]{case [#1][#2] \to #3, [#4][#5] \to #6}

\newcommand{\putbx}[3]{put \, [\![#1]\!] \ #2 \ #3}
\newcommand{\putbxinline}[1]{put \, [\![#1]\!]}
\newcommand{\getbx}[2]{get \, [\![#1]\!] \ #2}
\newcommand{\getbxinline}[1]{get \, [\![#1]\!]}

\newcommand{\putrev}[3]{put_{REV} \, [\![#1]\!] \ {#2} \ {#3}}
\newcommand{\getrev}[2]{get_{REV} \, [\![#1]\!] \ {#2}}

\newcommand{\pg}[3]{pg \, [\![#1]\!] (#2, #3)}
\newcommand{\pginline}[1]{pg \, [\![#1]\!]}

\newcommand{\cpg}[5]{cpg [\![#1]\!] (#2, #3, #4, #5)}
\newcommand{\cpginline}[1]{cpg \, [\![#1]\!]}

\newcommand{\kpg}[7]{kpg [\![#1]\!] (#2, #3, #4, #5, #6, #7)}
\newcommand{\kpginline}[1]{kpg \, [\![#1]\!]}

\newcommand{\xpg}[3]{xpg \, [\![#1]\!] (#2, #3)}
\newcommand{\xpginline}[1]{xpg \, [\![#1]\!]}

\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}p{#1}}

\begin{document}
%
\title{Bx to Rev (tentative) \thanks{Supported by organization x.}}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{First Author\inst{1}\orcidID{0000-1111-2222-3333} \and
Second Author\inst{2,3}\orcidID{1111-2222-3333-4444} \and
Third Author\inst{3}\orcidID{2222--3333-4444-5555}}
%
\authorrunning{F. Author et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Princeton University, Princeton NJ 08544, USA \and
Springer Heidelberg, Tiergartenstr. 17, 69121 Heidelberg, Germany
\email{lncs@springer.com}\\
\url{http://www.springer.com/gp/computer-science/lncs} \and
ABC Institute, Rupert-Karls-University Heidelberg, Heidelberg, Germany\\
\email{\{abc,lncs\}@uni-heidelberg.de}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
The abstract should briefly summarize the contents of the paper in
15--250 words.

\keywords{First keyword  \and Second keyword \and Another keyword.}
\end{abstract}
%
%
%
\section{Introduction}

% Story ->
% reversible is needed not to lose any information -> pg is introduced.
% pg is not good for lassoc -> cpg (xpg_2) is introduced.
% cpg can be improved -> kpg(xpg) is introduced.
% kpg is slower than pg for rassoc. combined version -> xpg.

% Evaluation result: Comparison with OCaml implementation of miniBiGUL

\begin{itemize}
\item Importance of BX, BX is a solution of view update problem in database.
\item Explanation of put-based BX: BiGUL.
\item Current status of BiGUL: Fastest BX language in the world
\item A problem: Efficiency of compose evaluation. If we do not save the intermediate states, the number of get is quadratic. This is not good.
\item To solve this problem we use an idea from reversible computation: not to lose any information.
\item Based on this idea we introduce pg.
\item We extend pg with several ideas and produce faster implementation.
\end{itemize}

\subsection{Contribution}

\begin{itemize}
\item Improvement of evaluation efficiency
\item Reveal a part of relationship between BX and Reversible.
  \begin{itemize}
  \item Very well-behaved (no adaptive-case) \& The same evaluation path $\to$ No garbage Reversible Computation.
  \item A pair of put and get is self-inverse (involution).
  \item If we can obtain good parameter (dummy) for a BiGUL program,
    put(s, dummy) can be a complement function.
  \end {itemize}
\item Introduced extentions (maybe) use more memory than the original approach, but they are faster than the original.
\end{itemize}

\subsection{Construction of this paper}

\begin{itemize}
\item 
\end{itemize}

\section{Bidirectional Programming Language: BiGUL}

\begin{itemize}
\item our target language is miniBiGUL (BiGUL minus adaptive case) : very well-behaved
\item get = s $\to$ v
\item put = s * v $\to$ s
\item explanation about get and put.
\item We assume putget and getput hold (explanation about putget and getput)
\item explanation about put-based BX language: BiGUL
\item Because our target language satisfies very well-behaved (No adaptive case) $\to$ putput hold.
\end{itemize}

\subsection{Semantics of miniBiGUL}

$\putbx{Skip \ h}{s}{v} = \sif{h \ s = v}{s}{\text{fail}}$

$\putbx{Replace}{s}{v} = v$

$\putbx{\product{bx_1}{bx_2}}{\tuple{s_1}{s_2}}{\tuple{v_1}{v_2}} =\\
    \tab \product{(\putbx{bx_1}{s_1}{v_1})}{(\putbx{bx_2}{s_2}{v_2})}$

$\putbx{\rearrS{f}{bx}}{s}{v} = f^{-1}(\putbx{bx}{(f \ s)}{v})$

$\putbx{\rearrV{g}{bx}}{s}{v} = \putbx{bx}{s}{(g \ v)}$

$\putbx{\casebx{cond_{sv_1}}{cond_{s_1}}{bx_1}{cond_{sv_2}}{cond_{s_2}}{bx_2}}{s}{v} = \\
    \tab \text{if } {cond_{sv_1} \ s \ v} \\
    \tab \text{then let } s' = \putbx{bx_1}{s}{v} \\
    \tab \text{else let } s' = \putbx{bx_2}{s}{v} \\
    \tab \text{fi } cond_{s_1} \ s'; \ \text{return} \ s'$

$\putbx{bx_1 \circ bx_2}{s}{v} = \putbx{bx_1}{s}{(\putbx{bx_2}{(\getbx{bx_1}{s})}{v})}$

\vspace{5mm}

$\getbx{Skip \ h}{s} = h \ s$

$\getbx{Replace}{s} = s$

$\getbx{\product{bx_1}{bx_2}}{\tuple{s_1}{s_2}} = \\
    \tab \product{(\getbx{bx_1}{s_1})}{(\getbx{bx_2}{s_2})}$

$\getbx{\rearrS{f}{bx}}{s} = \getbx{bx}{(f \ s)}$

$\getbx{\rearrV{g}{bx}}{s} = g^{-1} (\getbx{bx}{s})$

$\getbx{\casebx{cond_{sv_1}}{cond_{s_1}}{bx_1}{cond_{sv_2}}{cond_{s_2}}{bx_2}}{s} =\\
    \tab \text{if} \ {cond_{s_1} \ s}\\
    \tab \text{then let} \ v' = \getbx{bx_1}{s}\\
    \tab \text{else let} \ v' = \getbx{bx_2}{s}\\
    \tab \text{fi} \ {cond_{sv_1} \ s \ v'}; \ \text{return} \ v'$

$\getbx{bx_1 \circ bx_2}{s} = \getbx{bx_2}{(\getbx{bx_1}{s})}$

\begin{itemize}
\item To implement this in OCaml, we need some way to produce inverse function for $f$ and $g$.
\item Avoiding this, our implementation requires users to write inverse function f$^{-1}$ and g$^{-1}$.
\end{itemize}

\section{Skip:Reversible langauge: Rwhile}

% Maybe we should skip

\begin{itemize}
\item Usually programs receives inputs and produces outputs. It is impossible to produce inputs from outputs in general. Obtaining the inverse program of a program is difficult.
\item Using reversible language, we can obtain inverse programs easily.
\item Explanation of Rwhile: we need fi-condition.
\item syntax, how to work.
\end{itemize}

\section{Skip:First approach}

% We should skip this 

\begin{itemize}
\item Make put and get to be reversible. We need garbages (g) to keep lost infomation after evaluation.
\item put$_{REV}$ = s * v $\to$ s * g
\item get$_{REV}$ = s $\to$ v * g
\item introduce (put$_{REV}^{-1}$: s * g $\to$ s * v) and (get$_{REV}^{-1}$:v * g $\to$ s)
\item \textcolor{red}{(Missing part?)} Relationship between put$_{REV}$, get$_{REV}$, put$_{REV}^{-1}$, get$_{REV}^{-1}$ 
\end{itemize}

$\putrev{Skip \ h}{s}{v} =  \sif{h \ s = v}{(s, v)}{\text{fail}}$

$\putrev{Replace}{s}{v} = (v, s)$

$\putrev{\product{bx_1}{bx_2}}{\tuple{s_1}{s_2}}{\tuple{v_1}{v_2}} =\\
    \tab \text{let} \ (s_1, g_1) = \putrev{bx_1}{s_1}{v_1} \ \text{in}\\
    \tab \text{let} \ (s_2, g_2) = \putrev{bx_2}{s_2}{v_2} \ \text{in}\\
        \qtab ((s_1, s_2), (g_1, g_2))$

$\putrev{\rearrS{f}{bx}}{s}{v} =\\
    \tab \text{let} \ (s_1, g_1) = \putrev{bx}{(f \ s)}{v} \ \text{in}\\
        \qtab (f^{-1} s_1, g_1)$

$\putrev{\rearrV{g}{bx}}{s}{v} =\\
    \tab \text{let} \ (s_1, g_1) = \putrev{bx}{s}{(g \ v)} \ \text{in}\\
        \qtab (s_1, g_1)$

$\putrev{\casebx{cond_{sv_1}}{cond_{s_1}}{bx_1}{cond_{sv_2}}{cond_{s_2}}{bx_2}}{s}{v} =\\
    \tab \text{if} \ cond_{sv_1} \ s \ v\\
    \tab \text{then let} \ (s', g) = \putrev{bx_1}{s}{v} \ \text{in}\\
    \tab \text{else let} \ (s', g) = \putrev{bx_2}{s}{v} \ \text{in}\\
    \tab \text{fi} \ cond_{s_1} \ s'; \ \text{return} \ (s', g)$

$\putrev{bx_1 \circ bx_2}{s}{v} =\\
    \tab \text{let} \ (s_1, g_1) = \getrev{bx_1}{s} \ \text{in}\\
    \tab \text{let} \ (s_2, g_2) = \putrev{bx_2}{s_1}{v} \ \text{in}\\
    \tab \text{let} \ (s_3, g_3) = \putrev{bx_1}{s}{s_2} \ \text{in (* need to copy s *)}\\
        \qtab (s_3, (g_1, g_2, g_3))$

\vspace{5mm}

$\getrev{Skip \ h}{s} = {(h \ s, s)}$

$\getrev{Replace}{s} = (s, \textcolor{red}{\text{Nil}})$

$\getrev{\product{bx_1}{bx_2}}{\tuple{s_1}{s_2}} = \\
    \tab \text{let} \ (v_1, g_1) = \getrev{bx_1}{s_1} \ \text{in}\\
    \tab \text{let} \ (v_2, g_2) = \getrev{bx_2}{s_2} \ \text{in}\\
        \qtab ((v_1, v_2), (g_1, g_2))$

$\getrev{\rearrS{f}{bx}}{s}{v} =\\
    \tab \text{let} \ (v_1, g_1) = \getrev{bx}{(f \ s)} \ \text{in}\\
        \qtab (v_1, g_1)$

$\getrev{\rearrV{g}{bx}}{s}{v} =\\
    \tab \text{let} \ (v_1, g_1) = \getrev{bx}{s} \ \text{in}\\
        \qtab (g^{-1} v_1, g_1)$

$\getrev{\casebx{cond_{sv_1}}{cond_{s_1}}{bx_1}{cond_{sv_2}}{cond_{s_2}}{bx_2}}{s} =\\
    \tab \text{if} \ cond_{s_1} \ s\\
    \tab \text{then let} \ (v', g) = \getrev{bx_1}{s} \ \text{in}\\
    \tab \text{else let} \ (v', g) = \getrev{bx_2}{s} \ \text{in}\\
    \tab \text{fi} \ cond_{sv_1} \ s \ v'; \ \text{return} \ (v', g)$

$\getrev{bx_1 \circ bx_2}{s}{v} =\\
    \tab \text{let} \ (v_1, g_1) = \getrev{bx_1}{s} \ \text{in}\\
    \tab \text{let} \ (v_2, g_2) = \getrev{bx_1}{s} \ \text{in}\\
        \qtab (v_2, (g_1, g_2))$

\textcolor{red}{If we use Rwhile for target language, we do not need to introduce inverse.}

\section{pg}
\subsection{Self-inverse function: pg}

\begin{itemize}
\item Information loss causes re-evaluation of get.
\item To prevent this, we introduced the idea of reversible computation.
\item In reversible computation we need to keep all information: we can not lose any information.
\item In BiGul we can do this with a pair of put and get.
\item pg bx (s, v) = (put bx (s, v), get bx (s))
\item pg: s * v $\to$ s * v
\item No garbage
\item This function is self-inverse. (involution, (f (f input)) = input)
\item \textcolor{red}{Constraint: In case expression, put and get must always choose the same branch. This constraint is not satisfied in general: (e.g, SNOC, the different length of two inputs.) To remove this constraint we need to use garbage.}
\end{itemize}

For the approaches so far, when evaluating a composition of BX programs, $get$s are re-evaluated so many times since no intermediate state is stored during the evaluation. This is a kind of information loss. One question is whether it is possible to calculate the above programs without losing information. And the answer is yes. It comes from the the idea of reversible computation where all information during the evaluation need to be kept. In miniBiGUL, we can do that by tupling $put$ and $get$. The such pair is accepted as input of a function named $pg$ to produce a new one that contains the actual result of a BX program.

\begin{definition}
    $\pg{bx}{s}{v} = (\putbx{bx}{s}{v}, \getbx{bx}{s})$
\end{definition}

$pg$ is an involution that is self-inverse. An involution is a function $f$ that satifies $f(f(x)) = x \text{ for all } x \text{ in the domain of } f$.

\begin{proof}
$pg [\![bx]\!] \ (\pg{bx}{s}{v}) \\
    \tab = \pg{bx}{(\putbx{bx}{s}{v})}{(\getbx{bx}{s})} \quad [pg \text{ definition}] \\
    \tab = (put \ [\![bx]\!] \ (\putbx{bx}{s}{v}) \ (\getbx{bx}{s}), \getbx{bx}{(\putbx{bx}{s}{v})})  \quad [pg \text{ definition}] \\
    \tab = (put \ [\![bx]\!] \ (\putbx{bx}{s}{v}, \getbx{bx}{s}), v) \quad [\text{PUTGET}] \\
    \tab = (put \ [\![bx]\!] \ (s, \getbx{bx}{s}), v) \quad [\text{PUTPUT}] \\
    \tab = (s, v) \quad [\text{GETPUT}]$
\end{proof}

\subsection{Skip:Construction of pg}

$\pg{Skip \ h}{s}{v} \\
    \tab = (\sif{h \ s = v}{s}{\text{fail}}, h \ s) \\
    \tab = \sif{h \ s = v}{(s, h \ s)}{\text{fail}} \\
    \tab = \sif{h \ s = v}{(s, v)}{\text{fail}}$

There is a trick in the construction of $\pginline{Skip \ h}$. The first equality is simply based on the definitions of $pg$, $\putbxinline{Skip \ h}$ and $\getbxinline{Skip \ h}$. The second one tuples two results of $put$ and $get$ in the body of the if-expression. And the last one is quite obivious. What we call the trick here is in the second equality where in some cases, the result of $pg$ may be fail although there is no fail when evaluating $\getbxinline{Skip \ h}$.\\

$\pg{Replace}{s}{v}\\
    \tab = (v, s)$

$\pg{\product{bx_1}{bx_2}}{\tuple{s_1}{s_2}}{\tuple{v_1}{v_2}} \\
    \tab = (\product{(\putbx{bx_1}{s_1}{v_1})}{(\putbx{bx_2}{s_2}{v_2})}, \product{(\getbx{bx_1}{s_1})}{(\getbx{bx_2}{s_2})}) \\
    \tab = \text{let} \ (s_1, v_1) = \pg{bx_1}{s_1}{v_1} \ \text{in} \\
        \qtab \text{let} \ (s_2, v_2) = \pg{bx_2}{s_2}{v_2} \ \text{in} \\
        \qtab (\product{s_1}{s_2}, \product{v_1}{v_2})$

$\pg{\rearrS{f}{bx}}{s}{v} \\
    \tab = (f^{-1}(\putbx{bx}{(f \ s)}{v}), \getbx{bx}{(f \ s)}) \\
    \tab = \text{let} \ (s, v) = \pg{bx}{f \ s}{v} \ \text{in} \\
        \qtab (f^{-1} s, v)$

$\pg{\rearrV{g}{bx}}{s}{v} \\
    \tab = (\putbx{bx}{s}{(g v)}, g^{-1} (\getbx{bx}{s})) \\
    \tab = \text{let} \ (s, v) = \pg{bx}{s}{g \ v} \ \text{in} \\
        \qtab (s, g^{-1} v)$\\

Constructions of $pg$ for $[\![Replace]\!]$, $[\![\product{bx_1}{bx_2}]\!]$, $[\![\rearrS{f}{bx}]\!]$ and $[\![\rearrV{g}{bx}]\!]$ are very clear when just paring $put$ and $get$ respectively, then doing basic changes.\\

$\pg{\casebx{cond_{sv_1}}{cond_{s_1}}{bx_1}{cond_{sv_2}}{cond_{s_2}}{bx_2}}{s}{v} \\
    \tab = (\text{if} \ {cond_{sv_1} \ s \ v} \\
    \qtab \text{then let} \ s' = \putbx{bx_1}{s}{v} \\
    \qtab \text{else let} \ s' = \putbx{bx_2}{s}{v} \\
    \qtab \text{fi} \ cond_{s_1} \ s'; \text{ return } s', \\
    \qtab \quad \text{if} \ {cond_{s_1} \ s}\\
    \qtab \quad \text{then let} \ v' = \getbx{bx_1}{s}\\
    \qtab \quad \text{else let} \ v' = \getbx{bx_2}{s}\\
    \qtab \quad \text{fi} \ {cond_{sv_1} \ s \ v'}; \text{ return } v') \\
    \tab = \text{if} \ {cond_{sv_1} \ s \ v} \ and \ {cond_{s_1} \ s} \\
        \qtab \text{then let} \ (s', v') = \pg{bx_1}{s}{v}\\
        \qtab \text{else let} \ (s', v') = \pg{bx_2}{s}{v}\\
        \qtab \text{fi} \ cond_{v_1} \ s' \ and \ cond_{sv_1} \ s \ v'; \text{ return } (s',v')$\\

A restriction for $\pginline{case}$ needs to be introduced here. We know that there is one entering condition and one exit condition when evaluating $\putbxinline{case}$ as well as $\getbxinline{case}$. If a tupling $put$ and $get$ occurs, there will be 4 combinations of these conditions. This means that two entering conditions of $\putbxinline{case}$ and $\getbxinline{case}$ are not always simultaneously satified. The evaluated BXs are different in the $put$ and $get$ directions for combinations $((cond_{sv_1} \ s \ v) \ and \ (not (cond_{s_1} \ s)))$ and $((not (cond_{sv_1} \ s \ v) \ and \ (cond_{s_1} \ s))$, which are restricted in this paper. This does not happen for the others, which the construction of $\pginline{case}$ uses above. \\


$\pg{bx_1 \circ bx_2}{s}{v} \\
    \tab = (\putbx{bx_1}{s}{(\putbx{bx_2}{(\getbx{bx_1}{s})}{v})}, \getbx{bx_2}{(\getbx{bx_1}{s})}) \\
    \tab = \text{let} \ a = \getbx{bx_1}{s} \ \text{in} \\
        \qtab \text{let} \ (b, c) = \pg{bx_2}{a}{v} \ \text{in} \\
        \qtab \text{let} \ (d, e) = \pg{bx_1}{s}{b} \ \text{in} \\
        \qtab (d, c) \\
    \tab = \text{let} \ (f, a) = \pg{bx_1}{s}{dummy} \ \text{in} \\
        \qtab \text{let} \ (b, c) = \pg{bx_2}{a}{v} \ \text{in} \\
        \qtab \text{let} \ (d, e) = \pg{bx_1}{s}{b} \ \text{in} \\
        \qtab (d, c) \\
    \tab = \text{let } (f, a) = \pg{bx_1}{s}{dummy} \ \text{in} \\
        \qtab \text{let} \ (b, c) = \pg{bx_2}{a}{v} \ \text{in} \\
        \qtab \text{let} \ (d, e) = \pg{bx_1}{\textcolor{red}{f}}{b} \ \text{in} \\
        \qtab (d, c)$\\

The construction of $\pginline{bx_1 \circ bx_2}$ can be considered as the soul of the $pg$ function. The first two equalities comes from mentioned definitions and some basic transformations. The third one rewrites $(\text{let } a = \getbx{bx_1}{s} \text{ in})$ into $(\text{let } (f, a) = \pg{bx_1}{s}{dummy} \text{ in})$. It is possible if we consider $(\getbx{bx_1}{s})$ as the second element of $(\pg{bx_1}{s}{dummy})$ where $dummy$ is a special value that make the $put \, [\![bx_1]\!]$ direction is valid. The last equality substitutes $s$ in $(\text{let } (d, e) = \pg{bx_1}{s}{b} \text{ in})$ by $f$ which is the evaluated result of $\putbx{bx_1}{s}{dummy}$. This transformation is feasible due to the PUTPUT law. Then, $e$ in the result pair $(d,e)$ of the new let-expression equals $dummy$. So we can realize that there is no loss information when computing a composition.

\subsection{How to Evaluate Bidirectional Programs using pg}

\begin{itemize}
\item Because we combine put and get, we need to supply view for evaluation of get.
\item introduce dummy?
\item automatic analysis for domain \& range?
\item 
\item partial evaluation of put(s(D), dummy(S)).
\item \textcolor{red}{Not good? Basically put (BX) is often a recursion on the source. If source is static, partial evaluation will work well. On the other hand, view is small data. So partial evaluation might not work well.}
\item \textcolor{red}{lazy evaluation is also a possibility?}
\end{itemize}

\subsection{cpg}

\begin{itemize}
\item If the BX programs are left assoc of composition, pg will be exponential. Because it calls pg bx$_1$ twice.
\item To solve this problem, we introduce accumulation of changes.
\end{itemize}

$fst = \lambda (Con (x_1, x_2)). x_1$\\
$snd = \lambda (Con (x_1, x_2)). x_2$\\
$con = \lambda ks_1. \lambda ks_2. \lambda x. Con(ks_1 \ x, ks_2 \ x)$\\

$\cpg{bx}{ks}{kv}{s}{v}$ \\
    \tab $ks, kv$ keep modification information\\
    \tab $s, v$ keep evaluated values\\

\vspace{3mm}

$\cpg{Skip \ h}{ks}{kv}{s}{v} = \text{ if } h \ s = v \text{ then } (ks, kv, s, v) \text{ else fail}$\\

$\cpg{Replace}{ks}{kv}{s}{v} = (kv, ks, v, s)$\\

$\cpg{\product{bx_1}{bx_2}}{ks}{kv}{s}{v} =\\
    \tab (ks_1, kv_1, s_1, v_1) \Leftarrow \cpg{bx_1}{fst \circ ks}{fst \circ kv}{fst \ s}{fst \ v};\\
    \tab (ks_2, kv_2, s_2, v_2) \Leftarrow \cpg{bx_2}{snd \circ ks}{snd \circ kv}{snd \ s}{snd \ v};\\
    \qtab (con \ ks_1 \ ks_2, con \ kv_1 \ kv_2, Con \ s_1 \ s_2, Con \ v_1 \ v_2)$\\

$\cpg{RearrS \ f_1 \ f_2 \ bx}{ks}{kv}{s}{v} =\\
    \tab (ks, kv, s, v) \Leftarrow \cpg{bx}{f_1 \circ ks}{kv}{f_1 \ s}{v};\\
    \qtab (f_2 \circ ks, kv, s, v)$\\

$\cpg{RearrV \ g_1 \ g_2 \ bx}{ks}{kv}{s}{v} =\\
    \tab (ks, kv, s, v) \Leftarrow \cpg{bx}{ks}{g_1 \circ kv}{s}{g_1 \ v};\\
    \qtab (ks, g_2 \circ kv, ks, g_2 \ v)$\\

$\cpg{Case \ c \ bx_1 \ bx_2}{ks}{kv}{s}{v} =\\
    \tab \text{if} \ c \ s \ v \ \text{then}\\
        \qtab \cpg{bx_1}{ks}{kv}{s}{v}\\
    \tab \text{else} \\ 
        \qtab \cpg{bx_2}{ks}{kv}{s}{v}$\\

$\cpg{bx_1 \circ bx_2}{ks}{kv}{s}{v} =\\
    \tab (ks_1, kv_1, \underline{s_1}, v_1) \Leftarrow \cpg{bx_1}{ks}{id}{s}{const$\_$dummy \ v};\\
    \tab (ks_2, kv_2, s_2, v_2) \Leftarrow \cpg{bx_2}{kv_1}{kv}{v_1}{v};\\
        \qtab (ks_1 \circ ks_2, kv_2,  ks_1 \ s_2, v_2)$\\

$s \Leftarrow s_0; v \Leftarrow v_0;\\
(ks, kv, s, v) \Leftarrow \cpg{bx}{\lambda \_.s}{\lambda \_.v}{s}{v};\\
    \tab (s; v)$

\begin{itemize}
\item This is faster than pg for left assoc BX programs.
\item (Slower for right assoc programs)
\item $s_1'$ in composition is redundant.  
\item Next, we will extend this to avoid this redundant computation.
\end{itemize}


\subsection{kpg}

$\kpg{bx}{ks}{kv}{ks'}{kv'}{s}{v}$ \\
    \tab $ks, kv$ keep modification information\\
    \tab $ks', kv'$ evaluate actual values\\
    \tab $s, v$ keep evaluated values\\

\vspace{3mm}

$\kpg{Skip \ h}{ks}{kv}{ks'}{kv'}{s}{v} =\\
    \tab s \Leftarrow ks' \ s; \quad v \Leftarrow kv' \ v;\\
    \tab ks' \Leftarrow id; \quad kv' \Leftarrow id;\\
    \tab \text{if} \ h \ s = v \ \text{then} \ (ks, kv, ks', kv', s, v) \ \text{else fail}$\\

$\kpg{Replace}{ks}{kv}{ks'}{kv'}{s}{v} = (kv, ks, kv', ks', v, s)$\\

$\kpg{bx_1 \ prod \ bx_2}{ks}{kv}{ks'}{kv'}{s}{v} =\\
    \textcolor{red}{s \Leftarrow ks' \ s; \quad v \Leftarrow kv' \ v;}\\
    \textcolor{red}{ks' \Leftarrow id; \quad kv' \Leftarrow id;}\\
    (ks_1, kv_1, ks_1', kv_1', s_1, v_1) \Leftarrow \kpg{bx_1}{fst \circ ks}{fst \circ kv}{fst \circ ks'}{fst \circ kv'}{s}{v};\\
    (ks_2, kv_2, ks_2', kv_2', s_2, v_2) \Leftarrow \kpg{bx_2}{snd \circ ks}{snd \circ kv}{snd \circ ks'}{snd \circ kv'}{s}{v};\\
    \tab ( con \ ks_1 \ ks_2, con \ kv_1 \ kv_2, \\
    \tab con \ (ks_1' \circ fst) \ (ks_2' \circ snd), con \ (kv_1' \circ fst) \ (kv_2' \circ snd), \\
    \tab (Con \ s_1 \ s_2), (Con \ v_1 \ v_2))$\\

$\kpg{RearrS \ f_1 \ f_2 \ bx}{ks}{kv}{ks'}{kv'}{s}{v} =\\
    \tab (ks, kv, ks', kv', s, v) \Leftarrow \kpg{bx}{f_1 \circ ks}{kv}{f_1 \circ ks'}{kv'}{s}{v};\\
    \qtab (f_2 \circ ks, kv, f_2 \circ ks', kv', s, v)$\\

$\kpg{RearrV \ g_1 \ g_2 \ bx}{ks}{kv}{ks'}{kv'}{s}{v} =\\
    \tab (ks, kv, ks', kv', s, v) \Leftarrow \kpg{bx}{ks}{g_1 \circ kv}{ks'}{g_1 \circ kv'}{s}{v};\\
    \qtab (ks, g_2 \circ kv, ks', g_2 \circ kv', s, v)$\\

$\kpg{Case \ c \ bx_1 \ bx_2}{ks}{kv}{ks'}{kv'}{s}{v} =\\
    \tab s \Leftarrow ks' \ s; \tab v \Leftarrow kv' \ v;\\
    \tab ks' \Leftarrow id ; \tab kv' \Leftarrow id;\\
    \tab \text{if} \ c \ s \ v \ \text{then}\\
        \qtab \kpg{bx_1}{ks}{kv}{ks'}{kv'}{s}{v}\\
    \tab \text{else}\\\
        \qtab \kpg{bx_2}{ks}{kv}{ks'}{kv'}{s}{v}$\\

$\kpg{bx_1 \circ bx_2}{ks}{kv}{ks'}{kv'}{s}{v} =\\
    \tab (ks_1, kv_1, \underline{ks_1'}, kv_1', \underline{s_1}, v_1) \Leftarrow \kpg{bx_1}{ks}{id}{ks'}{id}{s}{const$\_$dummy \ v};\\
    \tab (ks_2, kv_2, ks_2', kv_2', s_2, v_2) \Leftarrow \kpg{bx_2}{kv_1}{kv}{kv_1'}{kv'}{v_1}{v};\\
    \qtab (ks_1 \circ ks_2, kv_2', ks_1 \circ ks_2', kv_2', s_2, v_2)$\\

$s \Leftarrow s_0; v \Leftarrow v_0;\\
(ks, kv, ks', kv', s, v) \Leftarrow \kpg{bx}{\lambda \_.s}{id}{id}{id}{s}{v};\\
    \tab (ks' \ s; kv' \ v)$

\begin{itemize}
\item In this definition of kpg, s' and v' will have actual value only in skip and case. Except them, the functions for computation will be kept as ks' and kv'.
\item In composition $ks_1'$ and $s_1'$ are still redundant. But, they are not evaluated.
\item In prod, Evaluation of ks' and kv' will be done indendently in kpg$[\![bx_1]\!]$ and kpg$[\![bx_2]\!]$. To remove redundant re-computation we evaluate actual s' and v'.
\item This implementation is faster for left assoc BX programs. (Actually slower for right assoc than cpg)
\end{itemize}

\section{xpg}

\begin{itemize}
\item pg is fastest for right assoc programs and kpg is fastest for left assoc programs.
\item To combine their strength, we can use the following definition.
\item If there is a composition, we use xpg for evaluation of $bx_1$ and pg for evaluation of $bx_2$.
\item If $bx_1$ is simple program (= Right assoc), this is almost the same with pg.
\item If $bx_1$ is complicated program (= Left assoc), this is almost the same with kpg.
\end{itemize}

$\xpg{E}{s}{v} = \text{same with } pg \text{ if } E \text{ is not compose}$

$\xpg{bx_1 \circ bx_2}{s}{v} =\\
    \tab (ks_1,kv_1, ks_1', kv_1', s_1, v_1) \Leftarrow \kpg{bx_1}{\lambda \_.s}{id}{id}{id}{s}{v};\\
    \tab (s_2, v_2) \Leftarrow \xpg{bx_2}{kv_1' \ v_1}{v};\\
    \qtab (ks_1 \ s_2, v_2)$

\section{Experiment}

This section describes the experiments involving $minBiGUl$, $pg$, $cpg$, $kpg$ and $xpg$. The evaluation time, the memory allocation and the number of function calls are considered in each test.

\subsection{Experiment environment}
We implemented 5 approaches with Ocaml 4.07.1 in the same environment as follows: macOS 10.14.6, processor Intel Core i7 (2.6 GHz), RAM 16 GB 2400 MHz DDR4. The Ocaml runtime system options and garbage collection parameters are set as default.  

\subsection{Test cases}
We are conducted tests on 5 cases, including many composition styles such as left or right associative, non-recursive or recursive. Table \ref{tab:test-cases} shows more details on these cases.

\begin{table}[]
    \centering
    \caption{Test cases}
    \label{tab:test-cases}
    \begin{tabular*}{\textwidth}{|c @{\extracolsep{\fill}}|l|l|l|c|c|c|c|}
        \hline
        \multirow{2}{*}{No} & \multicolumn{1}{c|}{\multirow{2}{*}{Name}} & \multicolumn{1}{c|}{\multirow{2}{*}{Associative}} & \multicolumn{1}{c|}{\multirow{2}{*}{Recursive}} & \multicolumn{2}{c|}{Input} & \multicolumn{2}{c|}{Output} \\ \cline{5-8} 
        & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{$s_0$} & \multicolumn{1}{c|}{$v_0$} & \multicolumn{1}{c|}{$s_r$} & \multicolumn{1}{c|}{$v_r$} \\ \hline
        1 & lassoc-comp-replace & left & no & 1 & 100 & 100 & 1 \\ \hline
        2 & rassoc-comp-replace & right & no & 1 & 100 & 100 & 1 \\ \hline
        3 & lassoc-comp-phead & left & no & $\underbrace{[[\ldots[1]\ldots]]}_{\text{n+1 times}}$ & 100 & $\underbrace{[[\ldots[100]\ldots]]}_{\text{n+1 times}}$ & 1 \\ \hline
        4 & rassoc-comp-phead & right & no & $\underbrace{[[\ldots[1]\ldots]]}_{\text{n+1 times}}$ & 100 & $\underbrace{[[\ldots[100]\ldots]]}_{\text{n+1 times}}$ & 1 \\ \hline
        5 & breverse & left & yes & [1..n] & [1..n] & [n..1] & [n..1] \\ \hline
    \end{tabular*}
\end{table}

In table \ref{tab:test-cases}, $s_r$ and $v_r$ are respectively updated source and view which are produced by applying $put$ and $get$ on original source $s_0$ and original view $v_0$. This means: $s_r = \putbx{bx}{s_0}{v_0}$ and $v_r = \getbx{bx}{s_0}$, where $bx$ is one of the 5 cases mentioned in the table. Note that the results $s_r$ and $v_r$ do not depend on the associative style of the composition.\\

The first 4 test cases simply use $n$ compose operators to make a composition of $n + 1$ similar $BX$ programs which are non-recursive. For example, \textit{lassoc-comp-replace} looks like $(\ldots((Replace \circ Replace) \circ Replace) \circ \ldots \circ Replace) \circ Replace$, while \textit{rassoc-comp-replace} is like $Replace \circ (Replace \circ (Replace \circ \ldots \circ (Replace \circ Replace)\ldots))$, where there are $n + 1 \ Replace$s in each case. \textit{lassoc-comp-phead} and \textit{rassoc-comp-phead} are similar to the above two. While $Replace$ is a primitive BX program, $phead$ is a combination of such programs. The following is the definition of $phead$ in BiGUL [?]:

    $\tab phead :: Show \ s \Rightarrow BiGUL \ [s] \ s\\
    \tab phead = \$(rearrS \ [\![\lambda(s:ss) \to (s,ss)]\!])\$\\
        \qtab \qtab \quad \$(rearrV \ [\![\lambda(v) \to (v,())]\!])\$\\
            \qtab \qtab \qquad Replace \ `prod\text{'} \ (Skip \ (const \ ()))$

We also provide the same $phead$ program in our Ocaml system. It rearranges the source, a non-empty list, to a pair of its head element $s$ and its tail $ss$, and the view to a pair $(v, ())$, then we can use $v$ to replace $s$ and $()$ to keep $ss$. $\putbx{phead}{s_0}{v_0}$ returns a list whose head is $v_0$ and tail is the tail of $s_0$. $\getbx{phead}{s_0}$ returns the head of $s_0$. For instance, $\putbx{phead}{[1,2,3]}{100} = [100,2,3]$ and $\getbx{phead}{[1,2,3]} = 1$. If we wanna update the head element of the head element of a list of lists by using the view, we can define a composition like $phead \circ phead$. For example:

    \tab $\putbx{phead \circ phead}{[[1,2,3],[\ ],[4,5]]}{100} = [[100,2,3],[\ ],[4,5]]$\\
    \tab $\getbx{phead \circ phead}{[[1,2,3],[\ ],[4,5]]} = 1$

Similarly, we can use the view to update head element in the nested lists with a composition of a specific number of $phead$s. For both \textit{lassoc-comp-phead} and \textit{rassoc-comp-phead}, we choose input view $v_0$ is 100 and input source $s_0$ is one of the smallest nested lists which make $put$ and $get$ direction on the composition valid.\\

The last test case, $bReverse$, is a left-associative and recursive composition. It is defined in terms of $bFoldr$, a putback function for $foldr$ in BiGUL as well as minBiGUL. What we know about $foldr$, an important higher-order function on lists, is as follows:\\
    $\tab foldr :: (a \to b \to b) \to b \to [a] \to b\\
    \tab foldr \ f \ e \ [\ ] = e\\
    \tab foldr \ f \ e \ (x:xs) = f \ x \ (foldr \ f \ e \ xs)$

We can define function $reverse$ on lists based on $foldr$:\\
    $\tab reverse \ [\ ] = [\ ]\\
    \tab reverse \ (x:xs) = snoc \ x \ (reverse \ xs)\\
    \tab reverse = foldr \ snoc \ [\ ]$

Let's see the following definition of $bFoldr$ which is a restricted version of $lensFoldr$ in [?] without adaptive cases:

$\tab bFoldr :: (Show \ a, Show \ v) \Rightarrow BiGUL \ (a, v) \ v \to BiGUL \ ([a], v) \ v\\
\tab bFoldr \ bx =\\
    \qtab Case \ [\$(normal \ [\![ \lambda (x,\_) v \to null \ x ]\!] \ [\![ \lambda (x,\_) \to null \ x ]\!])\\
        \qtab \qtab \Longrightarrow \$(rearrV [| \lambda v \to ((),v) |])\$\\
            \qtab \qtab \qtab (Skip \ (const \ ())) \ `Prod \text{'} \ Replace\\
    \qtab \qtab, \$(normal \ [\![ \lambda (x,\_) v \to not \ (null \ x) ]\!] \ [\![ \lambda (x,\_) \to not \ (null \ x) ]\!])\\
        \qtab \qtab \Longrightarrow \$(rearrS \ [\![ \lambda ((x:xs), e) \to (x, (xs,e)) |])\$\\
            \qtab \qtab \qtab (Replace \ `Prod\text{'} \ bFoldr \ bx) \ \circ \ bx\\
    \qtab \qtab]\\$

The detailed explanation of $bFoldr$ are skipped. Like $phead$, the program equipvalent to the above $bFoldr$ is also provided in our Ocaml system. If we put our eyes on the second branch of $bFoldr$, we can understand why it is recursive and left-associative composition. Note that the compose operator has a higher priority than the product operator. This leads to seemingly impossible to transform this function from left-associative style to right-associative style.

Suppose that we haved $bSnoc$, a bidirectional version of $snoc$, in BiGUL. Then $bReverse$ can defined as follows:

    $\tab bReverse :: Show \ a \Rightarrow BiGUL \ [a] \ [a]\\
    \tab bReverse =\\
        \qtab Case \ [ \$(adaptive \ [\![ \lambda s \ v \to length \ s \neq length \ v ]\!])\\
        \qtab \qtab \quad \lambda s \ v \to v\\
        \qtab \qtab , \$(normal \ [\![ \lambda s \ v \to True ]\!] \ [\![ \lambda s \to True ]\!])\\
        \qtab \qtab \quad \$(rearrS \ [\![ \lambda s \to (s,[\ ]) ]\!])\$\\
            \qtab \qtab \qquad bFoldr \ bSnoc\\
       \qtab \qtab ]$

The above definition contains an adaptive branch and it only occurs when the length of the source and the view are different. If we restrict them as two lists whose same lengths, the case analysis will only evaluate the normal branch. For test case $breverse$ in table \ref{tab:test-cases}, we choose both $s_0$ and $v_0$ as lists from 1 to $n$. Then, the results $s_r$ and $v_r$ are the list from $n$ to 1. Explicitly, $\putbx{bReverse}{[1..n]}{[1..n]} = [n..1]$ and $\getbx{bReverse}{[1..n]} = [n..1]$. In $bReverse$, the number of composition equals to the length of the source and the view.

\subsection{Results and discussions}
We conducted experiments on 5 test cases while changing the number of composition from 10 to 100000.

\begin{figure}
    \centering
    \subfloat[\textit{lassoc-comp-replace}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of composition},
                ylabel = {evaluation time (s)},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize},
                legend pos = north west
            ]
                \pgfplotstableread[col sep=comma]{csv/time-lassoc-comp-replace.csv}\data
                \addplot table[x=nComp,y=minbigul]{\data};
                \addlegendentry{minbigul};
                \addplot table[x=nComp,y=pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=cpg]{\data};
                \addlegendentry{cpg};
                \addplot table[x=nComp,y=kpg]{\data};
                \addlegendentry{kpg};
                \addplot table[x=nComp,y=xpg]{\data};
                \addlegendentry{xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \subfloat[\textit{rassoc-comp-replace}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of composition},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize},
                legend pos = north west
            ]
                \pgfplotstableread[col sep=comma]{csv/time-rassoc-comp-replace.csv}\data
                \addplot table[x=nComp,y=minbigul]{\data};
                \addlegendentry{minbigul};
                \addplot table[x=nComp,y=pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=cpg]{\data};
                \addlegendentry{cpg};
                \addplot table[x=nComp,y=kpg]{\data};
                \addlegendentry{kpg};
                \addplot table[x=nComp,y=xpg]{\data};
                \addlegendentry{xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \hspace{0mm}
    \subfloat[\textit{lassoc-comp-phead}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of composition},
                ylabel = {evaluation time (s)},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize},
                legend pos = north west
            ]
                \pgfplotstableread[col sep=comma]{csv/time-lassoc-comp-phead.csv}\data
                \addplot table[x=nComp,y=minbigul]{\data};
                \addlegendentry{minbigul};
                \addplot table[x=nComp,y=pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=cpg]{\data};
                \addlegendentry{cpg};
                \addplot table[x=nComp,y=kpg]{\data};
                \addlegendentry{kpg};
                \addplot table[x=nComp,y=xpg]{\data};
                \addlegendentry{xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \subfloat[\textit{rassoc-comp-phead}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of composition},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize},
                legend pos = north east
            ]
                \pgfplotstableread[col sep=comma]{csv/time-rassoc-comp-phead.csv}\data
                \addplot table[x=nComp,y=minbigul]{\data};
                \addlegendentry{minbigul};
                \addplot table[x=nComp,y=pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=cpg]{\data};
                \addlegendentry{cpg};
                \addplot table[x=nComp,y=kpg]{\data};
                \addlegendentry{kpg};
                \addplot table[x=nComp,y=xpg]{\data};
                \addlegendentry{xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \vspace{2mm}
    \subfloat[\textit{breverse}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of composition},
                ylabel = {evaluation time (s)},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize},
                legend pos = north east
            ]
                \pgfplotstableread[col sep=comma]{csv/time-breverse.csv}\data
                \addplot table[x=nComp,y=minbigul]{\data};
                \addlegendentry{minbigul};
                \addplot table[x=nComp,y=pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=cpg]{\data};
                \addlegendentry{cpg};
                \addplot table[x=nComp,y=kpg]{\data};
                \addlegendentry{kpg};
                \addplot table[x=nComp,y=xpg]{\data};
                \addlegendentry{xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \caption{Evaluation time (s)}
    \label{fig:evaluation-time}
\end{figure}

\begin{figure}
    \centering
    \subfloat[\textit{lassoc-comp-replace}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of composition},
                ylabel = {memory allocation (MBytes)},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize},
                legend pos = north west
            ]
                \pgfplotstableread[col sep=comma]{csv/mem-lassoc-comp-replace.csv}\data
                \addplot table[x=nComp,y=minbigul]{\data};
                \addlegendentry{minbigul};
                \addplot table[x=nComp,y=pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=cpg]{\data};
                \addlegendentry{cpg};
                \addplot table[x=nComp,y=kpg]{\data};
                \addlegendentry{kpg};
                \addplot table[x=nComp,y=xpg]{\data};
                \addlegendentry{xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \subfloat[\textit{rassoc-comp-replace}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of composition},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize},
                legend pos = north west
            ]
                \pgfplotstableread[col sep=comma]{csv/mem-rassoc-comp-replace.csv}\data
                \addplot table[x=nComp,y=minbigul]{\data};
                \addlegendentry{minbigul};
                \addplot table[x=nComp,y=pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=cpg]{\data};
                \addlegendentry{cpg};
                \addplot table[x=nComp,y=kpg]{\data};
                \addlegendentry{kpg};
                \addplot table[x=nComp,y=xpg]{\data};
                \addlegendentry{xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \hspace{0mm}
    \subfloat[\textit{lassoc-comp-phead}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of composition},
                ylabel = {memory allocation (MBytes)},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize},
                legend pos = north west
            ]
                \pgfplotstableread[col sep=comma]{csv/mem-lassoc-comp-phead.csv}\data
                \addplot table[x=nComp,y=minbigul]{\data};
                \addlegendentry{minbigul};
                \addplot table[x=nComp,y=pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=cpg]{\data};
                \addlegendentry{cpg};
                \addplot table[x=nComp,y=kpg]{\data};
                \addlegendentry{kpg};
                \addplot table[x=nComp,y=xpg]{\data};
                \addlegendentry{xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \subfloat[\textit{rassoc-comp-phead}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of composition},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize},
                legend pos = north east
            ]
                \pgfplotstableread[col sep=comma]{csv/mem-rassoc-comp-phead.csv}\data
                \addplot table[x=nComp,y=minbigul]{\data};
                \addlegendentry{minbigul};
                \addplot table[x=nComp,y=pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=cpg]{\data};
                \addlegendentry{cpg};
                \addplot table[x=nComp,y=kpg]{\data};
                \addlegendentry{kpg};
                \addplot table[x=nComp,y=xpg]{\data};
                \addlegendentry{xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \vspace{2mm}
    \subfloat[\textit{breverse}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of composition},
                ylabel = {memory allocation (MBytes)},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize},
                legend pos = north east
            ]
                \pgfplotstableread[col sep=comma]{csv/mem-breverse.csv}\data
                \addplot table[x=nComp,y=minbigul]{\data};
                \addlegendentry{minbigul};
                \addplot table[x=nComp,y=pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=cpg]{\data};
                \addlegendentry{cpg};
                \addplot table[x=nComp,y=kpg]{\data};
                \addlegendentry{kpg};
                \addplot table[x=nComp,y=xpg]{\data};
                \addlegendentry{xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \caption{Memory allocation (MBytes)}
    \label{fig:memory-allocation}
\end{figure}

\section{Conclusion and Future Work}


% From sample code
% 
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\begin{thebibliography}{8}
\bibitem{ref_article1}
Author, F.: Article title. Journal \textbf{2}(5), 99--110 (2016)

\bibitem{ref_lncs_1}
Author, F., Author, S.: Title of a proceedings paper. In: Editor,
F., Editor, S. (eds.) CONFERENCE 2016, LNCS, vol. 9999, pp. 1--13.
Springer, Heidelberg (2016). \doi{10.10007/1234567890}

\bibitem{ref_book1}
Author, F., Author, S., Author, T.: Book title. 2nd edn. Publisher,
Location (1999)

\bibitem{ref_proc1}
Author, A.-B.: Contribution title. In: 9th International Proceedings
on Proceedings, pp. 1--2. Publisher, Location (2010)

\bibitem{ref_url1}
LNCS Homepage, \url{http://www.springer.com/lncs}. Last accessed 4
Oct 2017
\end{thebibliography}
\end{document}







\subsubsection{Sample Heading (Third Level)} Only two levels of
headings should be numbered. Lower level headings remain unnumbered;
they are formatted as run-in headings.

\paragraph{Sample Heading (Fourth Level)}
The contribution should contain no more than four levels of
headings. Table~\ref{tab1} gives a summary of all heading levels.

\begin{table}
\caption{Table captions should be placed above the
tables.}\label{tab1}
\begin{tabular}{|l|l|l|}
\hline
Heading level &  Example & Font size and style\\
\hline
Title (centered) &  {\Large\bfseries Lecture Notes} & 14 point, bold\\
1st-level heading &  {\large\bfseries 1 Introduction} & 12 point, bold\\
2nd-level heading & {\bfseries 2.1 Printing Area} & 10 point, bold\\
3rd-level heading & {\bfseries Run-in Heading in Bold.} Text follows & 10 point, bold\\
4th-level heading & {\itshape Lowest Level Heading.} Text follows & 10 point, italic\\
\hline
\end{tabular}
\end{table}


\noindent Displayed equations are centered and set on a separate
line.
\begin{equation}
x + y = z
\end{equation}
Please try to avoid rasterized images for line-art diagrams and
schemas. Whenever possible, use vector graphics instead (see
Fig.~\ref{fig_1}).

\begin{figure}
\includegraphics[width=\textwidth]{fig_1.eps}
\caption{A figure caption is always placed below the illustration.
Please note that short captions are centered, while long ones are
justified by the macro package automatically.} \label{fig_1}
\end{figure}

\begin{theorem}
This is a sample theorem. The run-in heading is set in bold, while
the following text appears in italics. Definitions, lemmas,
propositions, and corollaries are styled the same way.
\end{theorem}
%
% the environments 'definition', 'lemma', 'proposition', 'corollary',
% 'remark', and 'example' are defined in the LLNCS documentclass as well.
%
\begin{proof}
Proofs, examples, and remarks have the initial word in italics,
while the following text appears in normal font.
\end{proof}
For citations of references, we prefer the use of square brackets
and consecutive numbers. Citations using labels or the author/year
convention are also acceptable. The following bibliography provides
a sample reference list with entries for journal
articles~\cite{ref_article1}, an LNCS chapter~\cite{ref_lncs_1}, a
book~\cite{ref_book1}, proceedings without editors~\cite{ref_proc1},
and a homepage~\cite{ref_url1}. Multiple citations are grouped
\cite{ref_article1,ref_lncs_1,ref_book1},
\cite{ref_article1,ref_book1,ref_proc1,ref_url1}.
%
