\appendix

\section{Remove?:First approach}

% We should skip this 

\begin{itemize}
\item Make put and get to be reversible. We need garbages (g) to keep lost infomation after evaluation.
\item put$_{REV}$ = s * v $\to$ s * gb
\item get$_{REV}$ = s $\to$ v * gb
\item introduce (put$_{REV}^{-1}$: s * gb $\to$ s * v) and (get$_{REV}^{-1}$:v * gb $\to$ s)
\item \textcolor{red}{(Missing part?)} Relationship between put$_{REV}$, get$_{REV}$, put$_{REV}^{-1}$, get$_{REV}^{-1}$ 
\end{itemize}

$\putrev{Skip \ h}{s}{v} =  \sif{h \ s = v}{(s, v)}{\text{fail}}$

$\putrev{Replace}{s}{v} = (v, s)$

$\putrev{\product{bx_1}{bx_2}}{(s_1 :: s_2)}{(v_1 :: v_2)} =\\
    \tab (s_1, gb_1) \Leftarrow \putrev{bx_1}{s_1}{v_1};\\
    \tab (s_2, gb_2) \Leftarrow \putrev{bx_2}{s_2}{v_2};\\
        \qtab (s_1 :: s_2, gb_1 :: gb_2)$

$\putrev{\rearrs{f_1}{f_2}{bx}}{s}{v} =\\
    \tab (s_1, gb_1) \Leftarrow \putrev{bx}{(f_1 \ s)}{v};\\
        \qtab (f_2 \ s_1, gb_1)$

$\putrev{\rearrv{g_1}{g_2}{bx}}{s}{v} =\\
    \tab (s_1, gb_1) \Leftarrow \putrev{bx}{s}{(g_1 \ v)};\\
        \qtab (s_1, gb_1)$

$\putrev{\casebx{cond_{sv}}{cond_{s}}{bx_1}{bx_2}}{s}{v} =\\
    \tab \text{if} \ cond_{sv} \ s \ v\\
    \tab \text{then} \ (s', gb) \Leftarrow \putrev{bx_1}{s}{v};\\
    \tab \text{else} \ (s', gb) \Leftarrow \putrev{bx_2}{s}{v};\\
    \tab \text{fi} \ cond_{s} \ s'; \ \text{return} \ (s', gb)$

$\putrev{bx_1 \circ bx_2}{s}{v} =\\
    \tab (s_1, gb_1) \Leftarrow \getrev{bx_1}{s};\\
    \tab (s_2, gb_2) \Leftarrow \putrev{bx_2}{s_1}{v};\\
    \tab (s_3, gb_3) \Leftarrow \putrev{bx_1}{s}{s_2} \ \text{in (* need to copy s *)}\\
        \qtab (s_3, gb_1 :: gb_2 :: gb_3)$

\vspace{5mm}

$\getrev{Skip \ h}{s} = {(h \ s, s)}$

$\getrev{Replace}{s} = (s, \textcolor{red}{\text{Nil}})$

$\getrev{\product{bx_1}{bx_2}}{(s_1 :: s_2)} = \\
    \tab (v_1, gb_1) \Leftarrow \getrev{bx_1}{s_1};\\
    \tab (v_2, gb_2) \Leftarrow \getrev{bx_2}{s_2};\\
        \qtab (v_1 :: v_2, gb_1 :: gb_2)$

$\getrev{\rearrs{f_1}{f_2}{bx}}{s}{v} =\\
    \tab (v_1, gb_1) \Leftarrow \getrev{bx}{(f_1 \ s)};\\
        \qtab (v_1, gb_1)$

$\getrev{\rearrv{g_1}{g_2}{bx}}{s}{v} =\\
    \tab (v_1, gb_1) \Leftarrow \getrev{bx}{s};\\
        \qtab (g_2 \ v_1, gb_1)$

$\getrev{\casebx{cond_{sv}}{cond_{s}}{bx_1}{bx_2}}{s} =\\
    \tab \text{if} \ cond_{s} \ s\\
    \tab \text{then} \ (v', gb) \Leftarrow \getrev{bx_1}{s};\\
    \tab \text{else} \ (v', gb) \Leftarrow \getrev{bx_2}{s};\\
    \tab \text{fi} \ cond_{sv} \ s \ v'; \ \text{return} \ (v', gb)$

$\getrev{bx_1 \circ bx_2}{s}{v} =\\
    \tab (v_1, gb_1) \Leftarrow \getrev{bx_1}{s};\\
    \tab (v_2, gb_2) \Leftarrow \getrev{bx_1}{s};\\
        \qtab (v_2, gb_1 :: gb_2)$

\textcolor{red}{If we use Rwhile for target language, we do not need to introduce inverse.}

\section{minBiGUL}
Now, let's consider the definition of $phead$ in BiGUL [?]:

$\tab phead :: Show \ s \Rightarrow BiGUL \ [s] \ s\\
\tab phead = \$(RearrS \ [\![\lambda(s:ss) \to (s,ss)]\!])\$\\
    \qtabs{2} \quad \$(RearrV \ [\![\lambda v \to (v,())]\!])\$\\
        \qtabs{2} \qquad Replace \ `prod\text{'} \ (Skip \ (const \ ()))$

The above program rearranges the source, a non-empty list, to a pair of its head element $s$ and its tail $ss$, and the view to a pair $(v, ())$, then we can use $v$ to replace $s$ and $()$ to keep $ss$. $\putbx{phead}{s_0}{v_0}$ returns a list whose head is $v_0$ and tail is the tail of $s_0$. $\getbx{phead}{s_0}$ returns the head of $s_0$. For instance, $\putbx{phead}{[1,2,3]}{100} = [100,2,3]$ and $\getbx{phead}{[1,2,3]} = 1$.\\

In minBiGUL, we can express $phead$ as follows:

$\tab phead = RearrS \ f_1 \ f_2 \ bx_s \ \text{where:}\\
    \qtab f_1 = \lambda (s::ss).(s,ss)\\
    \qtab f_2 = \lambda (s,ss).(s::ss)\\
    \qtab bx_s = RearrV \ g_1 \ g_2 \ bx_v \ \text{where:}\\
        \qtabs{2} g_1 = \lambda v.(v,())\\
        \qtabs{2} g_2 = \lambda (v,()).v\\
        \qtabs{2} bx_v = \product{Replace}{(Skip \ (\lambda \_.())}$\\

Then, we can evaluate $\putbxinline{phead}$ and $\getbxinline{phead}$ based on their definitions:

$\putbx{phead}{[1,2,3]}{100}\\
\tab = \putbx{\rearrs{f_1}{f_2}{bx_s}}{[1,2,3]}{100}\\
\tab = f_2 \ (\putbx{bx_s}{(f_1 \ [1,2,3])}{100})\\
\tab = f_2 \ (\putbx{\rearrv{g_1}{g_2}{bx_v}}{(1,[2,3])}{100})\\
\tab = f_2 \ (\putbx{bx_v}{(1,[2,3])}{(g_1 \ 100}))\\
\tab = f_2 \ (\putbx{\product{Replace}{(Skip \ (\lambda \_.()))}}{(1,[2,3])}{(100,())})\\
\tab = f_2 \ ((\putbx{Replace}{1}{100}), (\putbx{(Skip \ (\lambda \_.()))}{[2,3]}{()}))\\
\tab = f_2 \ (100, [2,3])\\
\tab = [100,2,3]$\\

$\getbx{phead}{[1,2,3]}\\
\tab = \getbx{\rearrs{f_1}{f_2}{bx_s}}{[1,2,3]}\\
\tab = \getbx{bx_s}{(f_1 \ [1,2,3])}\\
\tab = \getbx{\rearrv{g_1}{g_2}{bx_v}}{(1,[2,3])}\\
\tab = g_2 \ (\getbx{bx_v}{(1,[2,3])})\\
\tab = g_2 \ (\getbx{\product{Replace}{(Skip \ (\lambda \_.()))}}{(1,[2,3])})\\
\tab = g_2 \ ((\getbx{Replace}{1}), (\getbx{(Skip \ (\lambda \_.()))}{[2,3]}))\\
\tab = g_2 \ (1,())\\
\tab = 1$\\

If we wanna update the head element of the head element of a list of lists by using the view, we can define a composition like $phead \circ phead$. For example:

    \tab $\putbx{phead \circ phead}{[[1,2,3],[\,],[4,5]]}{100} = [[100,2,3],[\,],[4,5]]$\\
    \tab $\getbx{phead \circ phead}{[[1,2,3],[\,],[4,5]]} = 1$\\

We distingwish two $phead$s in the composition by indices. According to definitions of $\putbxinline{bx}$ and $\getbxinline{bx}$, we have:

$\getbx{phead_1 \circ phead_2}{[[1,2,3],[\,],[4,5]]}\\
    \tab = \getbx{phead_2}{(\getbx{phead_1}{[[1,2,3],[\,],[4,5]]})}\\
    \tab = \getbx{phead_2}{[1,2,3]}\\
    \tab = 1$\\

$\putbx{phead_1 \circ phead_2}{[[1,2,3],[\,],[4,5]]}{100}\\
    \tab = \putbx{phead_1}{[[1,2,3],[\,],[4,5]]}{(\putbx{phead_2}{(\getbx{phead_1}{[[1,2,3],[\,],[4,5]]})}{100})}\\
    \tab = \putbx{phead_1}{[[1,2,3],[\,],[4,5]]}{(\putbx{phead_2}{[1,2,3]}{100})}\\
    \tab = \putbx{phead_1}{[[1,2,3],[\,],[4,5]]}{[100,2,3]}\\
    \tab = [[100,2,3],[\,],[4,5]]$\\

One more example we would like to present is $replaceAll$ whose definition in BiGUL as follows:\\
$\tab replaceAll :: (Eq \ s, Show \ s) \Rightarrow BiGUL \ [s] \ s \\ 
\tab replaceAll = Case \ [\\
    \qtab \$(normal \ [\![\lambda s \ v \to length \ s == 1]\!][\![\lambda s \to length \ s == 1]\!]) \\ 
    \qtab \Longrightarrow \$(rearrS \ [\![\lambda [x] \to x]\!]) Replace,\\
    \qtab \$(normal \ [\![\lambda s \ v \to length \ s > 1]\!][\![\lambda s \to length \ s > 1]\!]) \\ 
    \qtab \Longrightarrow \$(rearrS \ [\![\lambda (x:xs) \to (x,xs)]\!])\$\\ 
    \qtabs{2} \$(rearrV \ [\![\lambda v \to (v,v)]\!])\$\\ 
    \qtabs{2} Replace \ `prod\text{'} \ replaceAll\\
\tab ]$\\

The following expresses $replaceAll$ in minBiGUL:\\
$\tab replaceAll = Case \ cond_{sv} \ cond_{s} \ bx_1 \ bx_2 \ \text{where:}\\ 
    \qtab cond_{sv} = \lambda s.\lambda v.length \ s == 1\\
    \qtab cond_{s} = \lambda s.length \ s == 1\\ 
    \qtab bx_1 = RearrS \ (\lambda [x] \to x) \ (\lambda x \to [x]) \ Replace\\ 
    \qtab bx_2 = RearrS \ (\lambda (x::xs) \to (x,xs)) \ (\lambda (x,xs) \to (x::xs)) \ bx_s \ \text{where:}\\ 
        \qtab \tab bx_s = RearrV \ (\lambda v \to (v,v)) \ (\lambda (v,v) \to v) \ bx_v \ \text{where:}\\
            \qtabs{2} bx_v = \product{Replace}{replaceAll}$

We can also evaluate $\putbxinline{replaceAll}$ and $\getbxinline{replaceAll}$ similarly to the previous examples if we pay attention to conditions $cond_sv$ and $cond_s$ as well as the if-then-esle-fi structure. $\putbxinline{replaceAll}$ uses the view to update all elements in the source list, while $\getbxinline{replaceAll}$ returns the an element of the source list with same elements. For example, $\putbx{replaceAll}{[1,2,3]}{100} = [100,100,100]$ and $\getbx{replaceAll}{[1,1,1]} = 1$.

\section{Evaluation by pg}

By the definition of $pg$, we have:
$\pg{phead}{[1,2,3]}{100}\\
    \tab = (\putbx{phead}{[1,2,3]}{100}), \getbx{phead}{[1,2,3]})\\
    \tab = ([100,2,3], 1)$\\

On the other hand, we can evaluate $\pginline{phead}$ due to the construction of $pg$:
$\pg{phead}{[1,2,3]}{100}\\
    \tab = \pg{\rearrs{f_1}{f_2}{bx_s}}{[1,2,3]}{100}\\
    \tab = (s, v) \Leftarrow \pg{bx_s}{f_1 \ [1,2,3]}{100};\\
        \qtab \tab (f_2 \ s, v)\\
    \tab = (s, v) \Leftarrow \pg{\rearrv{g_1}{g_2}{bx_v}}{(1,[2,3])}{100};\\
        \qtab \tab (f_2 \ s, v)\\
    \tab = (s, v) \Leftarrow \{\\
        \qtab \tab (s, v) \Leftarrow \pg{bx_v}{(1,[2,3])}{g_1 \ 100};\\
        \qtab \tab (s, g_2 \ v)\\
        \qtab \};\\
        \qtab \tab (f_2 \ s, v)\\
    \tab = (s, v) \Leftarrow \{\\
        \qtab \tab (s, v) \Leftarrow \pg{\product{Replace}{(Skip \ (\lambda \_.()))}}{(1,[2,3])}{((100,()))};\\
        \qtab \tab (s, g_2 \ v)\\
        \qtab \};\\
        \qtab \tab (f_2 \ s, v)\\
    \tab = (s, v) \Leftarrow \{\\
        \qtab \tab (s, v) \Leftarrow \{\\
            \qtabs{2} (s_1, v_1) \Leftarrow \pg{Replace}{1}{100};\\
            \qtabs{2} (s_2, v_2) \Leftarrow \pg{(Skip \ (\lambda \_.()))}{[2,3]}{()};\\
            \qtabs{2} ((s_1,s_2), (v_1,v_2))\\
        \qtab \tab \};\\
        \qtab \tab (s, g_2 \ v)\\
        \qtab \};\\
        \qtab \tab (f_2 \ s, v)\\
    \tab = (s, v) \Leftarrow \{\\
        \qtab \tab (s, v) \Leftarrow \{\\
            \qtabs{2} (s_1, v_1) \Leftarrow (100, 1);\\
            \qtabs{2} (s_2, v_2) \Leftarrow ([2,3], ());\\
            \qtabs{2} ((s_1,s_2), (v_1,v_2))\\
        \qtab \tab \};\\
        \qtab \tab (s, g_2 \ v)\\
        \qtab \};\\
        \qtab \tab (f_2 \ s, v)\\
    \tab = (s, v) \Leftarrow \{\\
        \qtab \tab (s, v) \Leftarrow ((100,[2,3]), (1,()))\\
        \qtab \tab (s, g_2 \ v)\\
        \qtab \};\\
        \qtab \tab (f_2 \ s, v)\\
    \tab = (s, v) \Leftarrow ((100, [2,3]), 1);\\
        \qtab \tab (f_2 \ s, v)\\
    \tab = ([100,2,3], 1)$\\

We also have the evaluation of $\pginline{phead_1 \circ phead_2}$ as follows:

$\pg{phead_1 \circ phead_2}{[[1,2,3],[\,],[4,5]]}{100}\\
    \tab = (s_1, v_1) \Leftarrow \pg{phead_1}{[[1,2,3],[\,],[4,5]}{dummy};\\
        \qtab (s_2, v_2) \Leftarrow \pg{phead_2}{v_1}{100};\\
        \qtab (s_3, v_3) \Leftarrow \pg{phead_1}{s_1}{s_2};\\
            \qtab \tab (s_3, v_2)\\
    \tab = (s_1, v_1) \Leftarrow ([dummy,[\,],[4,5]], [1,2,3]);\\
        \qtab (s_2, v_2) \Leftarrow \pg{phead_2}{[1,2,3]}{100};\\
        \qtab (s_3, v_3) \Leftarrow \pg{phead_1}{s_1}{s_2};\\
            \qtab \tab (s_3, v_2)\\
    \tab = (s_1, v_1) \Leftarrow ([dummy,[\,],[4,5]], [1,2,3]);\\
        \qtab (s_2, v_2) \Leftarrow ([100,2,3], 1);\\
        \qtab (s_3, v_3) \Leftarrow \pg{phead_1}{[dummy,[\,],[4,5]]}{[100,2,3]};\\
            \qtab \tab (s_3, v_2)\\
    \tab = (s_1, v_1) \Leftarrow ([dummy,[\,],[4,5]], [1,2,3]);\\
        \qtab (s_2, v_2) \Leftarrow ([100,2,3], 1);\\
        \qtab (s_3, v_3) \Leftarrow ([[100,2,3],[\,],[4,5]], dummy);\\
            \qtab \tab (s_3, v_2)\\
    \tab = ([[100,2,3],[\,],[4,5]], 1)$\\

In the above evaluation, we do not clearly contruct what $dummy$ is. As we mentioned, $dummy$ is a special value which makes the first $\pginline{phead_1}$ valid. In this case, if we care about the type of $dummy$, it should be a list of integers. Thus, we can choose $dummy$ is an arbitrary list which has that type, for instance, an empty list or the head element of the source.

\section{Experiments-1}
In table \ref{tab:test-cases}, $s_r$ and $v_r$ are respectively updated source and view which are produced by applying $put$ and $get$ on original source $s_0$ and original view $v_0$. This means: $s_r = \putbx{bx}{s_0}{v_0}$ and $v_r = \getbx{bx}{s_0}$, where $bx$ is one of the 5 cases mentioned in the table. Note that the results $s_r$ and $v_r$ do not depend on the associative style of the composition.\\

The first 4 test cases simply use $n$ compose operators to make a composition of $n + 1$ similar $BX$ programs which are non-recursive. For example, \textit{lassoc-comp-replace}, left-associative composition of $Replace$s, looks like $(\ldots((Replace \circ Replace) \circ Replace) \circ \ldots \circ Replace) \circ Replace$, while \textit{rassoc-comp-replace}, right-associative composition of $Replace$s, is like $Replace \circ (Replace \circ (Replace \circ \ldots \circ (Replace \circ Replace)\ldots))$, where there are $n + 1 \ Replace$s in each case. \textit{lassoc-comp-phead} and \textit{rassoc-comp-phead} are similar to the above two.

In section 3, we defined a composition $phead \circ phead$ for updating the head element of the head element of a list of lists by using the view. Similarly, we can use the view to update head element in the nested lists with a composition of a specific number of $phead$s. For both \textit{lassoc-comp-phead} and \textit{rassoc-comp-phead}, we choose input view $v_0$ is 100 and input source $s_0$ is one of the smallest nested lists which make $put$ and $get$ directions on the composition valid.\\

The last test case, $bReverse$, is a recursive composition. It is defined in terms of $bFoldr$, a putback function for $foldr$ in BiGUL as well as minbigul. What we know about $foldr$, an important higher-order function on lists, is as follows:\\
    $\tab foldr :: (a \to b \to b) \to b \to [a] \to b\\
    \tab foldr \ f \ e \ [\,] = e\\
    \tab foldr \ f \ e \ (x:xs) = f \ x \ (foldr \ f \ e \ xs)$

We can define function $reverse$ on lists based on $foldr$:\\
    $\tab reverse \ [\,] = [\,]\\
    \tab reverse \ (x:xs) = snoc \ x \ (reverse \ xs)\\
    \tab reverse = foldr \ snoc \ [\,]$

Let's see the following definition of $bFoldr$ which is a restricted version of $lensFoldr$ in [?] without adaptive cases:

$\tab bFoldr :: (Show \ a, Show \ v) \Rightarrow BiGUL \ (a, v) \ v \to BiGUL \ ([a], v) \ v\\
\tab bFoldr \ bx =\\
    \qtab Case \ [\$(normal \ [\![ \lambda (x,\_) v \to null \ x ]\!] \ [\![ \lambda (x,\_) \to null \ x ]\!])\\
        \qtabs{2} \Longrightarrow \$(RearrV [| \lambda v \to ((),v) |])\$\\
            \qtabs{3} (Skip \ (const \ ())) \ `Prod \text{'} \ Replace\\
    \qtabs{2}, \$(normal \ [\![ \lambda (x,\_) v \to not \ (null \ x) ]\!] \ [\![ \lambda (x,\_) \to not \ (null \ x) ]\!])\\
        \qtabs{2} \Longrightarrow \$(RearrS \ [\![ \lambda ((x:xs), e) \to (x, (xs,e)) |])\$\\
            \qtabs{3} (Replace \ `Prod\text{'} \ bFoldr \ bx) \ \circ \ bx\\
    \qtabs{2}]\\$

The detailed explanation of $bFoldr$ are skipped. Like $phead$, the program equipvalent to the above $bFoldr$ is also provided in our OCaml system. In the second branch of $bFoldr$, there is a composition of two BX programs where the first requires a recursive call. Then this composition can be classified as either left or right associative type. However it will look like a composition of more BX programs at some point if we slow down to evaluate it. Note that the compose operator has a higher priority than the product operator. This leads to seemingly impossible to transform the above composition from left-associative style to right-associative style.

Suppose that we haved $bSnoc$, a bidirectional version of $snoc$, in BiGUL. Then $bReverse$ can defined as follows:

    $\tab bReverse :: Show \ a \Rightarrow BiGUL \ [a] \ [a]\\
    \tab bReverse =\\
        \qtab Case \ [ \$(adaptive \ [\![ \lambda s \ v \to length \ s \neq length \ v ]\!])\\
        \qtabs{2} \quad \lambda s \ v \to v\\
        \qtabs{2} , \$(normal \ [\![ \lambda s \ v \to True ]\!] \ [\![ \lambda s \to True ]\!])\\
        \qtabs{2} \quad \$(RearrS \ [\![ \lambda s \to (s,[\,]) ]\!])\$\\
            \qtabs{2} \qquad bFoldr \ bSnoc\\
       \qtabs{2} ]$

The above definition contains an adaptive branch and it only occurs when the lengths of the source and the view are different. If we restrict them as two lists whose same lengths, the case analysis will only evaluate the normal branch. For test case $breverse$ in table \ref{tab:test-cases}, we choose both $s_0$ and $v_0$ as lists from 1 to $n$. Then, the results $s_r$ and $v_r$ are the list from $n$ to 1. Explicitly, $\putbx{bReverse}{[1..n]}{[1..n]} = [n..1]$ and $\getbx{bReverse}{[1..n]} = [n..1]$. In $bReverse$, the number of compositions equals to the length of the source and the view.

\section{A}
\begin{table}[]
    \centering
    \caption{Comparison}
    \label{tab:comparison}
    \resizebox{\textwidth}{!}{%
        \begin{tabular}{|l|l|l|l|}
            \hline
            \multicolumn{1}{|c|}{Name} & \multicolumn{1}{c|}{Properties} & \multicolumn{1}{c|}{Evaluation time order} & \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}Memory allocation order\\ (stack\_overflow point / 100000)\end{tabular}} \\ \hline
            lassoc-comp-replace & l, NR & xpg $\sim$ kpg $<$ cpg $<$ minbigul $<$ pg & minbigul $<$ cpg $<$ xpg $\sim$ kpg (95299) $<$ pg (ND) \\ \hline
            rassoc-comp-replace & r, NR & minbigul $<$ pg $<$ xpg $<$ cpg $<$ kpg & minbigul $<$ pg $<$ xpg $<$ cpg (95299) $<$ kpg (80638) \\ \hline
            lassoc-comp-phead & l, NR & xpg $<$ kpg $<$ minbigul $<$ cpg $<$ pg & minbigul $<$ xpg $\sim$ kpg (80638) $<$ cpg (ND) $<$ pg (ND) \\ \hline
            rassoc-comp-phead & r, NR & minbigul $<$ pg $<$ xpg $<$ cpg $<$ kpg & minbigul $<$ pg $<$ xpg $<$ cpg (43680) $<$ kpg (61665) \\ \hline
            breverse & l/r, R & xpg $<$ kpg $<$ minbigul $<$ cpg $<$ pg & xpg (ND) $<$ kpg (ND) $<$ cpg (ND) $<$ minbigul (ND) $<$ pg (ND) \\ \hline
            \multicolumn{4}{r}{} \\
            \multicolumn{4}{r}{stack\_overflow point (default: $>$ 100000): can not evaluate a program if the number of compositions is larger than this point} \\
            \multicolumn{4}{r}{best $< \ldots < \ldots <$ worst} \\
            \multicolumn{4}{r}{l/r: left/right associative} \\
            \multicolumn{4}{r}{NR/R: non-recursive/recursive} \\
            \multicolumn{4}{r}{ND: not determined}
        \end{tabular}%
    }
\end{table}

Table \ref{tab:comparison} indicates a general comparison of the above results over the evaluation time and the memory allocation. This table provides some additional information about the point where a stack overflow error occurs in our OCaml system. We conducted tests while increasing the number of compositions from 10 to 100000. By default, the stack overflow point in the table is larger than 100000. In some cases, we limited the number of compositions because the corresponding evaluation times are too long. Then the above points are not determined.  

\subsection{Results and discussions}

We will in turn consider the empirical results about the number of function calls, the evaluation time and the memory allocation.\\

\begin{figure}
    \centering
    \subfloat[\textit{lassoc-comp-replace}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of compositions},
                ylabel = {number of calls},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize,at={(0.15,0.78)},anchor=west},
            ]
                \pgfplotstableread[col sep=comma]{csv/count-lassoc-comp-replace.csv}\data
                \addplot table[x=nComp,y=count_get]{\data};
                \addlegendentry{get};
                \addplot table[x=nComp,y=count_put]{\data};
                \addlegendentry{put};
                \addplot table[x=nComp,y=count_pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=count_xpg]{\data};
                \addlegendentry{cpg/kpg/xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \subfloat[\textit{rassoc-comp-replace}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of compositions},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize,at={(0.03,0.78)},anchor=west},
            ]
                \pgfplotstableread[col sep=comma]{csv/count-rassoc-comp-replace.csv}\data
                \addplot table[x=nComp,y=count_get]{\data};
                \addlegendentry{get};
                \addplot table[x=nComp,y=count_put]{\data};
                \addlegendentry{put};
                \addplot table[x=nComp,y=count_pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=count_xpg]{\data};
                \addlegendentry{cpg/kpg/xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \hspace{0mm}
    \subfloat[\textit{lassoc-comp-phead}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of compositions},
                ylabel = {number of calls},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize,at={(0.15,0.78)},anchor=west},
            ]
                \pgfplotstableread[col sep=comma]{csv/count-lassoc-comp-phead.csv}\data
                \addplot table[x=nComp,y=count_get]{\data};
                \addlegendentry{get};
                \addplot table[x=nComp,y=count_put]{\data};
                \addlegendentry{put};
                \addplot table[x=nComp,y=count_pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=count_xpg]{\data};
                \addlegendentry{cpg/kpg/xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \subfloat[\textit{rassoc-comp-phead}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of compositions},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize,at={(0.03,0.78)},anchor=west},
            ]
                \pgfplotstableread[col sep=comma]{csv/count-rassoc-comp-phead.csv}\data
                \addplot table[x=nComp,y=count_get]{\data};
                \addlegendentry{get};
                \addplot table[x=nComp,y=count_put]{\data};
                \addlegendentry{put};
                \addplot table[x=nComp,y=count_pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=count_xpg]{\data};
                \addlegendentry{cpg/kpg/xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \vspace{2mm}
    \subfloat[\textit{breverse}]{
        \begin{tikzpicture}
            \begin{axis}[
                xmode = normal,
                ymode = normal,
                xlabel = {number of compositions},
                ylabel = {number of calls},
                width = 0.55\linewidth,
                legend style = {font=\scriptsize,at={(0.47,0.78)},anchor=west},
            ]
                \pgfplotstableread[col sep=comma]{csv/count-breverse.csv}\data
                \addplot table[x=nComp,y=count_get]{\data};
                \addlegendentry{get};
                \addplot table[x=nComp,y=count_put]{\data};
                \addlegendentry{put};
                \addplot table[x=nComp,y=count_pg]{\data};
                \addlegendentry{pg};
                \addplot table[x=nComp,y=count_xpg]{\data};
                \addlegendentry{cpg/kpg/xpg};
            \end{axis}
        \end{tikzpicture}
    }
    \caption{Number of calls}
    \label{fig:count-calls}
\end{figure}

Fig \ref{fig:count-calls} depicts the number of function calls including $put$, $get$, $pg$, $cpg$, $kpg$ and $xpg$ for each test case. From definitions of $put$, $cpg$, $kpg$ and $xpg$, we have No($cpg$) = No($kpg$) = No($xpg$) = No($put$) where No($f$) is the number of function call $f$. Here we consider that No($xpg$) in evaluating $\xpginline{bx_1 \circ bx_2}$ includes both the number of $kpg$s which are used in $\kpginline{bx_1}$ and the number of $xpg$s which are used in $\xpginline{bx_2}$.\\

For right-associative and non-recursive compositions (\textit{rassoc-comp-replace} and \textit{rassoc-comp-phead}), No($get$), No($put$) and No($pg$) are linear where No($get$) $<$ No($put$) $<$ No($pg$).\\

For left-associative and non-recursive compositions (\textit{lassoc-comp-replace} and \textit{lassoc-comp-phead}), No($put$) is still linear while No($get$) is quadratic and No($pg$) is under an exponential distribution. In this case, No($put$) $<$ No($get$) $<$ No($pg$).\\

For recursive composition (\textit{breverse}), the results still show that No($put$) $<$ No($get$) $<$ No($pg$) but all three are nonlinear. In case of \textit{breverse}, No($put$) is quadratic, No($get$) is cubic and No($pg$) is exponential.\\

Fig \ref{fig:evaluation-time} illustrates the evaluation times in 5 test cases.\\

$pg$ times are always exponential for both left-associative compositions (\textit{lassoc-comp-replace}, \textit{lassoc-comp-phead}) and recursive compositions (\textit{breverse}) since the number of $pg$s in these cases are under exponential distributions.\\

For left-associative and non-recursive compositions, $kpg$ times are approximate to $xpg$ times, and they are the most efficient. In case of \textit{lassoc-comp-replace}, $kpg$ time and $xpg$ time are linear, $cpg$ time and $minbigul$ time are nonlinear. They are quite reasonable because the data sizes are constant, No($get$) is quadractic for minbigul while there is a linear redundant evaluation in $cpg$. In case of \textit{lassoc-comp-phead}, since the data sizes are linear and the numbers of function calls are either linear or quadractic or exponential, all times are nonlinear\\

For right-associative and non-recursive compositions, $minbigul$, $pg$ and $xpg$ times are linear. In case of \textit{rassoc-comp-replace}, all times are small enough to consider all them as linear. In case of \textit{rassoc-comp-phead}, both $cpg$ and $kpg$ times are quadratic because the data sizes are linear and the number of redundant evaluations are also linear.\\

For recursive compositions (\textit{breverse}), all times should be nonlinear since there is no linear number of function calls.\\



Fig \ref{fig:memory-allocation} shows the memory usage which depends on the input size and number of compositions. In general, $minbigul$ uses less memory than the others for non-recursive compositions (all tests except \textit{breverse}). $pg$ only uses memory efficient when handling right-associative compositions. Also for evaluating these  compositions, both $cpg$ and $kpg$ are worst in memory allocation. For recursive compositions (\textit{breverse}), $minbigul$ uses significantly more memory than $kpg$ as well as $xpg$.