\section{Experiments (old)}

This section describes the experiments involving $minBiGUL$, $pg$, $cpg$, $kpg$ and $xpg$. The evaluation time and the memory allocation are considered in each test.

\subsection{Experiment environment \& Test cases}
We implemented 5 approaches with OCaml 4.07.1 in the same environment as follows: macOS 10.14.6, processor Intel Core i7 (2.6 GHz), RAM 16 GB 2400 MHz DDR4. The OCaml runtime system options and garbage collection parameters are set as default.

We also conducted tests on 5 cases, including many composition styles such as left or right associative, non-recursive or recursive. Table \ref{tab:test-cases} shows more details on these cases.

\begin{table}[hbt!]
    \centering
    \caption{Test cases}
    \label{tab:test-cases}
    \begin{tabular*}{\textwidth}{|c @{\extracolsep{\fill}}|l|l|l|c|c|c|c|}
        \hline
        \multirow{2}{*}{No} & \multicolumn{1}{c|}{\multirow{2}{*}{Name}} & \multicolumn{1}{c|}{\multirow{2}{*}{Associative}} & \multicolumn{1}{c|}{\multirow{2}{*}{Recursive}} & \multicolumn{2}{c|}{Input} & \multicolumn{2}{c|}{Output} \\ \cline{5-8} 
        & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{$s_0$} & \multicolumn{1}{c|}{$v_0$} & \multicolumn{1}{c|}{$s_r$} & \multicolumn{1}{c|}{$v_r$} \\ \hline
        1 & lassoc-comp-replace & left & no & 1 & 100 & 100 & 1 \\ \hline
        2 & rassoc-comp-replace & right & no & 1 & 100 & 100 & 1 \\ \hline
        3 & lassoc-comp-phead & left & no & $\underbrace{[[\ldots[1]\ldots]]}_{\text{n+1 times}}$ & 100 & $\underbrace{[[\ldots[100]\ldots]]}_{\text{n+1 times}}$ & 1 \\ \hline
        4 & rassoc-comp-phead & right & no & $\underbrace{[[\ldots[1]\ldots]]}_{\text{n+1 times}}$ & 100 & $\underbrace{[[\ldots[100]\ldots]]}_{\text{n+1 times}}$ & 1 \\ \hline
        5 & breverse & left/right & yes & [1..n] & [1..n] & [n..1] & [n..1] \\ \hline
    \end{tabular*}
\end{table}

In table \ref{tab:test-cases}, $s_r$ and $v_r$ are respectively updated source and view which are produced by applying $put$ and $get$ on original source $s_0$ and original view $v_0$. This means: $s_r = \putbx{bx}{s_0}{v_0}$ and $v_r = \getbx{bx}{s_0}$, where $bx$ is one of the 5 cases mentioned in the table. Note that the results $s_r$ and $v_r$ do not depend on the associative style of the composition. The first four test cases simply use $n$ compose operators to make a composition of $n + 1$ similar $BX$ programs which are non-recursive. For example, \textit{lassoc-comp-replace}, left-associative composition of $Replace$s, looks like $(\ldots((Replace \circ Replace) \circ Replace) \circ \ldots \circ Replace) \circ Replace$, while \textit{rassoc-comp-replace}, right-associative composition of $Replace$s, is like $Replace \circ (Replace \circ (Replace \circ \ldots \circ (Replace \circ Replace)\ldots))$, where there are $n + 1 \ Replace$s in each case. The last test case, \textit{breverse}, is defined in terms of \textit{bFoldr}, a putback function for \textit{foldr} which is an important higher-order function on lists. This case is more natural than the other since \text{bFoldr} is a Case analysis whose a branch contains a composition $bx_1 \circ bx_2$ where $bx_1$ is a product of a simple function and $bFoldr$. It will look like a composition of more BX programs at some point if we slow down the evaluation. Note that $\circ$ has a higher priority than $\times$. This leads to seemingly impossible to transform \textit{bReverse} as well as \textit{bFoldr} from left-associative style to right-associative style.

\subsection{Results and discussions}

Firstly, from definitions of $put$, $cpg$, $kpg$ and $xpg$, we have No($cpg$) = No($kpg$) = No($xpg$) = No($put$) where No($f$) is the number of function call $f$. Here we consider that No($xpg$) in evaluating $\xpginline{bx_1 \circ bx_2}$ includes both the number of $kpg$s which are used in $\kpginline{bx_1}$ and the number of $xpg$s which are used in $\xpginline{bx_2}$. For right-associative and non-recursive compositions (\textit{rassoc-comp-replace} and \textit{rassoc-comp-phead}), No($get$), No($put$) and No($pg$) are linear. For left-associative and non-recursive compositions (\textit{lassoc-comp-replace} and \textit{lassoc-comp-phead}), No($put$) is still linear while No($get$) is quadratic and No($pg$) is under an exponential distribution. For recursive composition (\textit{breverse}), all three are nonlinear. The appendix will provide more complete insights about those statements. Now we take a closer look at the empirical results.

%\input{result.tex}

Fig \ref{fig:result}a illustrates the evaluation times in 5 test cases. $pg$ times are always exponential for both left-associative compositions (\textit{lassoc-comp-replace}, \textit{lassoc-comp-phead}) and recursive compositions (\textit{breverse}) since No($pg$) in each case is under an exponential distribution. For left-associative and non-recursive compositions, $kpg$ times are approximate to $xpg$ times, and they are the most efficient. In case of \textit{lassoc-comp-replace}, $kpg$ time and $xpg$ time are linear, $cpg$ time and $minBiGUL$ time are nonlinear. They are quite reasonable because the data sizes are constant, No($get$) is quadractic for $minBiGUL$ while there is a linear quantity of redundant evaluations in $cpg$. In case of \textit{lassoc-comp-phead}, since the data sizes are linear and No($f$) are either linear or quadractic or exponential, all times are nonlinear. For right-associative and non-recursive compositions, $minBiGUL$, $pg$ and $xpg$ times are linear. In case of \textit{rassoc-comp-replace}, all times are small enough to consider all them as linear. In case of \textit{rassoc-comp-phead}, both $cpg$ and $kpg$ times are quadratic because the data sizes are linear and the number of redundant evaluations are also linear. For recursive compositions (\textit{breverse}), all times should be nonlinear since there is no linear number of function calls.\\
Fig \ref{fig:result}b shows the memory usage which depends on the input size and number of compositions. In general, $minBiGUL$ uses less memory than the others for non-recursive compositions (all tests except \textit{breverse}). $pg$ only uses memory efficient when handling right-associative compositions. Also for evaluating these  compositions, both $cpg$ and $kpg$ are worst in memory allocation. For recursive compositions (\textit{breverse}), $minBiGUL$ uses significantly more memory than $kpg$ as well as $xpg$.