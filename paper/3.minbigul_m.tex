\section{Adding Memoization: minBiGUL$_m$} \label{sect:minbigulm}

When evaluating the composition of several BX programs, 
% (and the same holds for 
% full BiGUL), 
% all BX languages), 
the same $get$s are evaluated repeatedly.
% because no intermediate states are kept during the evaluation. 
This problem was illustrated in Figure~\ref{fig:eval-comp-phead}. To avoid reevaluating $get$s, and as our first approach to avoid this inefficiency, we introduce memoization in the minBiGUL interpreter.
% can save 
To keep it simple, the intermediate state of a composition is saved in a key-value table where the key is a pair of program $bx$ and source $s$, and the value is the result of evaluating $\getbx{bx}{s}$.
% the first time. 
% Then, instead of recomputing the value, the value in the table is used.
Later the value in the table is used instead of recomputing it. 

The memoizing version, minBiGUL$_m$, needs only two modifications: $get_m$ and $put_m$ (Definitions~\ref{def:putm} and~\ref{def:getm}). The auxiliary function, $get_{mh}$, is used to retrieve the value of an already evaluated $get$ from the table or to compute an unevaluated $get$ by $get_m$ and store the key-value tuple in the table (Definition~\ref{def:getmh}).

\begin{definition} \label{def:putm} $\text{Memo version of } put$

    \noindent $\putm{bx}{s}{v} = \match{bx}\\
        \tab \vert \ bx_1 \circ bx_2 \to \putm{bx_1}{s}{(\putm{bx_2}{(\getmh{bx_1}{s})}{v})} \\
        \tab \vert \ \_ \to \text{similar to } put$
\end{definition}

\begin{multicols}{2}
    \begin{definition} \label{def:getm} $\text{Memo version of } get$

        \noindent $\getm{bx}{s} = \match{bx}\\
            \tab \ \vert \ bx_1 \circ bx_2 \to\\
            \tabs{2} \textnormal{try } (\text{Hashtbl.find} \ table_g \ (bx, s))\\
            \tabs{2} \textnormal{with } \text{Not\_found } \to\\
                \tabs{3} v \Leftarrow \getmh{bx_2}{(\getmh{bx_1}{s})}\\
                \tabs{3} \text{Hashtbl.add } \ table_g \ (bx, s) \ v\\
                \tabs{3} v \\
            \tab \ \vert \ \_ \to \text{similar to } get$
    \end{definition}
\columnbreak
    \begin{definition} \label{def:getmh} $\text{Interface for } get_m$

        \noindent $\getmh{bx}{s} =\\
            \tab \textnormal{try } (\text{Hashtbl.find} \ table_g \ (bx, s))\\
            \tab \textnormal{with } \text{Not\_found } \to\\
                \tabs{2} v \Leftarrow \getm{bx}{s}\\
                \tabs{2} \match{bx} \\
                \tabs{2} \ \vert \ bx_1 \circ bx_2 \to v \\
                \tabs{2} \ \vert \ \_ \to \text{Hashtbl.add } \ table_g \ (bx, s) \ v\\
                \qtabs{2} \ v$
    \end{definition}
\end{multicols}

% Note as a special point 
% It should be noted 
Note in particular 
that the interpreter does not save all states when evaluating a program, only the intermediate states of a composition. When evaluating $\putm{bx_1 \circ bx_2}{s}{v}$, the function $get_{mh}$ is used, not $get$ or $get_m$.
% appears to indicate the saving. 
When evaluating $\getm{bx_1 \circ bx_2}{s}$, the key ($bx,s$), where $bx \equiv bx_1 \circ bx_2$, is looked up in the table and the corresponding value is used for the next steps in the evaluation. If there is no such key, the value $v$ will be calculated by using $get_{mh}$. This key-value insertion is necessary because the interpreter may later need to reevaluate $\getm{bx_1 \circ bx_2}{s}$.
% reevaluate <--> evaluate one more time.
